#!/usr/bin/ruby

# Requirements
require 'syslog'
require 'twitter'
require 'pp'

# Constants
APPNAME = "TCTBot"
VERSION = "0.1.1"
DEBUG = true

# Global Variables Initialization
$shutdown = false
$minute = -1
$dots = ""

# Configuration
# TODO: Read these from a config file
$twitter_handle = "OaklabsDev00"
# (twitter client keys)

#TODO: Load previously stored program state

# Open Syslog
Syslog.open(APPNAME, Syslog::LOG_CONS|Syslog::LOG_PID, Syslog::LOG_DAEMON)

# Log application startup
Syslog.info("%s v.%s Startup", APPNAME, VERSION)

# Create Twitter Client Object
client = Twitter::REST::Client.new do |config|
	config.consumer_key        = "mee99Pk9ldaAngB1UmQcvC7XF"
	config.consumer_secret     = "fjB1GTf0qRsiMkbF9FYtk8dhyktt0HnkA7wovF8IH7zPOEGJGP"
	config.access_token        = "1245470305499385856-0yE734tlAboqYCjYYHLwPTooSrJrBZ"
	config.access_token_secret = "LSWGkbQFHuZTzfMX9ZS9hdejrT2OpDo9H5x7CmW6JW55M"
end

# Retireve most recent tweet (index 0 of returned Enumerable)
lasttweet = client.user_timeline($twitter_handle, count: 1)[0]
Syslog.info("Most recent %s tweet at startup: \"%s...\"", $twitter_handle, lasttweet.text[0,26])

# Timing Loop
while $shutdown != true
	loop do	
		time = Time.now
		lastminute = $minute
		if ! DEBUG
			$minute = time.min
		else
			sleep 1
			$minute += 1
			$minute = 0 if $minute == 60 
		end

		# Scheduler
		case $minute

		when 0 # Post a new Poll
			$pollid = "%d%02d%02d%02d" % [time.year, time.month, time.day, time.hour]
			$pollid = $pollid.to_i
			Syslog.info("Posting a new poll! (ID: %d)", $pollid)
			tweet = "Poll %d: Should I BUY, SELL, or HODL? (Reply to this tweet with one of the keywords BUY, SELL, or HODL. The Twitter API does not yet support polls. Most recent message counts as your vote, multiple keywords ignored.)" % [$pollid]
			if tweet.length > 280
				Syslog.err("Error: Poll tweet too long! (%d characters", tweet.length)
			end
			if ! DEBUG
				client.update(tweet)
				sleep 60
			end

		when 03 #55 # Close the Poll
			# Retrieve most recent tweet
			$tweets = client.user_timeline($twitter_handle, count: 1)
			$lasttweet = $tweets[0]
			Syslog.info("Retrieved most recent %s tweet (poll): \"%s...\"", $twitter_handle, $lasttweet.text[0,26])

			#Extract the Poll ID
			$pollid = $lasttweet.text[/\b(?<!\.)\d+(?!\.)\b/, 0]
			if ! $pollid
				Syslog.err("Unable to retrieve Poll ID from most recent tweet! %s", $pollid.inspect)
				break
			end

			Syslog.info("Closing Poll %s", $pollid)
			if $lasttweet
				# Get all replies to the account after our poll tweet
				query = "to:%s" % $twitter_handle
				reply_tweets = client.search(query, since_id: lasttweet.id, result_type: "recent")
				#p reply_tweets if DEBUG
				Syslog.debug("Got %d replies to user.", reply_tweets.count) if DEBUG
				# TODO: Twitter only returns max 100 responses per query; loop until all replies have been collected.

				# Find subset of replies that replied directly to our poll tweet
				replies = []
				index = 0
				for tweet in reply_tweets do
					if tweet.in_reply_to_status_id == lasttweet.id
						replies[index] = tweet
						index += 1
					end
				end
				# Reverse order so that tweets are in chronological order
				replies = replies.reverse

				Syslog.debug("Got %d replies to poll.", replies.size) if DEBUG
				if DEBUG
					for tweet in replies do
						Syslog.debug("%s said: \"%s\"", tweet.user.screen_name, tweet.text)
					end
				end

				# Count the votes from replies
				votes = {}
				for tweet in replies do
					# Parse the tweet text for the vote keywords
					tweet.text =~ /buy/i  ? buy  = true  : buy  = false 
					tweet.text =~ /sell/i ? sell = true  : sell = false 
					tweet.text =~ /hodl/i ? hodl = true  : hodl = false 
					# Ensure that the tweet only contains one keyword
					if [buy, sell, hodl].one?
						# Add the voted keyword to the votes hash. Most recent vote per user will be counted.
						votes[tweet.user.screen_name] = "BUY"  if buy  == true
						votes[tweet.user.screen_name] = "SELL" if sell == true
						votes[tweet.user.screen_name] = "HODL" if hodl == true
					end
				end              
				Syslog.debug("Got %d votes in poll.", votes.size) if DEBUG
				#p votes if DEBUG
				if DEBUG
					votes.each do |name, vote|
						Syslog.debug("%s voted: \"%s\"", name, vote)
					end
				end

				# Check if we have our minimum threshold of votes. Default to HODL if 
				if votes.size < 1 #10
					Syslog.info("Only received %d votes (< 10), HODL!", votes.size)
					#client.update("Hourly voting closed.  Not enough votes to make a decision.  HODL!!! (Need minimum 10 votes... Maybe you should retweet my poll tweet?)") 
					$decision = "HODL"
				else
					# We have enough votes!  Make some trades...
					Syslog.info("Enough votes tallied, making a decision!")
					# TODO: Determine which keyword won the vote and set the decision variable
					tally = {}
					tally[:buy]  = 0
					tally[:sell] = 0
					tally[:hodl] = 0
					votes.each do |name, vote|
						tally[:buy]  += 1 if vote == "BUY"
						tally[:sell] += 1 if vote == "SELL"
						tally[:hodl] += 1 if vote == "HODL"
					end
					# Find the largest number in the tally hash and return the associated key(s)
					winner = tally.reduce({}){|h,(k,v)| (h[v] ||= []) << k;h}.max
					# There can be only one:
					$decision = "HODL" #default
					if winner[1].count > 1
						# Tie!  HODL...
						message = "Result of the poll was a tie! I'm gonna %s. (%d BUY | %d SELL | %d HODL)" % [$decision, tally[:buy], tally[:sell], tally[:hodl]]
						Syslog.info(message)
						client.update(message) if ! DEBUG
					else
						# Winner!
						$decision = "BUY"  if winner[1][0] == :buy
						$decision = "SELL" if winner[1][0] == :sell
						$decision = "HODL" if winner[1][0] == :hodl
					end

				end
			end

			# Post poll results
			message = "The results for Poll %d are in! %s is the winner! (%d BUY | %d SELL | %d HODL)" % [$pollid, $decision, tally[:buy], tally[:sell], tally[:hodl]]
			Syslog.info(message)
			client.update(message) if ! DEBUG

			# Execute desired trade via Cryptomnio
			Syslog.info("Executing trades via Cryptomnio...")
			# TODO: Integrate Cryptomnio back-end
			case $decision
			when "BUY"

			when "SELL"

			else
				# HODL
			end

			# Post trade results
			Syslog.info("Posting trade results...")
			sleep 60 if ! DEBUG
		else
			if lastminute != $minute
				$dots = ""
			else
				$dots = $dots + "."
			end
			printf("\rWaiting until minute 55... (Current minute: %02d) %s", $minute, $dots)
			STDOUT.flush
			sleep 0.05
		end
	end

end

