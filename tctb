#!/usr/bin/ruby

# Requirements
require 'syslog'
require 'yaml'
require 'twitter'
require 'pp'
require 'cryptomnio'

# Constants
APPNAME = "TCTBot"
VERSION = "0.1.1"
DEBUG = true

# Global Variables Initialization
$shutdown = false
$minute = -1
$dots = ""

# Configuration
def read_config
	@configfile = YAML.load( File.open('tctb.config').read )
	pp @configfile.inspect if DEBUG
rescue Errno::ENOENT => e
	puts "Config File 'tctb.config' NOT FOUND"
	puts e.message
	puts e.backtrace if DEBUG
	exit
end

read_config

$twitter_handle = @configfile[:twitter][:username]
# (twitter client keys)

# Open Syslog
Syslog.open(APPNAME, Syslog::LOG_CONS|Syslog::LOG_PID, Syslog::LOG_DAEMON)

# Log application startup
Syslog.info("%s v.%s Startup", APPNAME, VERSION)

# Create Twitter Client Object
client = Twitter::REST::Client.new do |c|
	c.consumer_key        = @configfile[:twitter][:consumer_key]
	c.consumer_secret     = @configfile[:twitter][:consumer_secret]
	c.access_token        = @configfile[:twitter][:access_token]
	c.access_token_secret = @configfile[:twitter][:access_token_secret]
end

# Create Cryptomnio Client Object
cryptomnio = Cryptomnio::REST::Client.new do |c|
	c.config = {
		# API Endpoint URL
		apiurl: @configfile[:cryptomnio][:apiurl],
		# Authentication
      authtype: "Basic",
      username: @configfile[:cryptomnio][:username],
      password: @configfile[:cryptomnio][:password],
      apikeys:  []
   }

	# Exchange API Keys
	@configfile[:cryptomnio][:apikeys].each do |key|
		c.config[:apikeys].push({
			exchange:   key[:exchange],
			key:        key[:key],
			secret:     key[:secret],
			clientid:   key[:clientid],
			passphrase: key[:passphrase]
		})
	end
end

# Authenticate Cryptomnio
cryptomnio.auth_basic

# Check for valid stored key and upload keys from config if there are none
keys = cryptomnio.get_all_exchange_keys
if keys.size < 1
	cryptomnio.upload_api_keys
else
	@ckey = keys[0]
end

# Populate Wallets Hash
@wallet_balances = cryptomnio.wallet_get( @ckey )
Syslog.info("Wallet Balances at startup: BTC: %s | USD: $%s", @wallet_balances["btc"]["amount"], @wallet_balances["usd"]["amount"]) 

# Retireve most recent tweet (index 0 of returned Enumerable)
lasttweet = client.user_timeline($twitter_handle, count: 1)[0]
Syslog.info("Most recent %s tweet at startup: \"%s...\"", $twitter_handle, lasttweet.text[0,26])

# Timing Loop
while $shutdown != true
	loop do	
		time = Time.now
		lastminute = $minute
		if ! DEBUG
			$minute = time.min
		else
			sleep 1
			$minute += 1
			$minute = 0 if $minute == 60 
		end

		# Scheduler
		case $minute

		when 0 # Post a new Poll
			# Refresh Wallet Balances
			@wallet_balances = cryptomnio.wallet_get( @ckey )

			# Generate a new Poll ID
			$pollid = "%d%02d%02d%02d" % [time.year, time.month, time.day, time.hour]
			$pollid = $pollid.to_i
			Syslog.info("Posting a new poll! (ID: %d)", $pollid)
			tweet = "Poll %d: Should I BUY, SELL, or HODL? (BTC: %s | USD: \$%s) (Reply to this tweet with one of the keywords BUY, SELL, or HODL. The Twitter API does not yet support polls. Most recent message counts as your vote, multiple keywords ignored.)" % [ $pollid, @wallet_balances["btc"]["amount"], @wallet_balances["usd"]["amount"] ]
			if tweet.length > 280
				Syslog.err("Error: Poll tweet too long! (%d characters", tweet.length)
			end
			puts tweet if DEBUG
#			client.update(tweet)
#			sleep 60

		when 03 #55 # Close the Poll
			# Retrieve most recent tweet
			$tweets = client.user_timeline($twitter_handle, count: 1)
			$lasttweet = $tweets[0]
			Syslog.info("Retrieved most recent %s tweet (poll): \"%s...\"", $twitter_handle, $lasttweet.text[0,26])

			#Extract the Poll ID
			$pollid = $lasttweet.text[/\b(?<!\.)\d+(?!\.)\b/, 0]
			if ! $pollid
				Syslog.err("Unable to retrieve Poll ID from most recent tweet! %s", $pollid.inspect)
				break
			end

			Syslog.info("Closing Poll %s", $pollid)
			if $lasttweet
				# Get all replies to the account after our poll tweet
				query = "to:%s" % $twitter_handle
				reply_tweets = client.search(query, since_id: lasttweet.id, result_type: "recent")
				#p reply_tweets if DEBUG
				Syslog.debug("Got %d replies to user.", reply_tweets.count) if DEBUG
				# TODO: Twitter only returns max 100 responses per query; loop until all replies have been collected.

				# Find subset of replies that replied directly to our poll tweet
				replies = []
				index = 0
				for tweet in reply_tweets do
					if tweet.in_reply_to_status_id == lasttweet.id
						replies[index] = tweet
						index += 1
					end
				end
				# Reverse order so that tweets are in chronological order
				replies = replies.reverse

				Syslog.debug("Got %d replies to poll.", replies.size) if DEBUG
				if DEBUG
					for tweet in replies do
						Syslog.debug("%s said: \"%s\"", tweet.user.screen_name, tweet.text)
					end
				end

				# Count the votes from replies
				votes = {}
				for tweet in replies do
					# Parse the tweet text for the vote keywords
					tweet.text =~ /buy/i  ? buy  = true  : buy  = false 
					tweet.text =~ /sell/i ? sell = true  : sell = false 
					tweet.text =~ /hodl/i ? hodl = true  : hodl = false 
					# Ensure that the tweet only contains one keyword
					if [buy, sell, hodl].one?
						# Add the voted keyword to the votes hash. Most recent vote per user will be counted.
						votes[tweet.user.screen_name] = "BUY"  if buy  == true
						votes[tweet.user.screen_name] = "SELL" if sell == true
						votes[tweet.user.screen_name] = "HODL" if hodl == true
					end
				end              
				Syslog.debug("Got %d votes in poll.", votes.size) if DEBUG
				#p votes if DEBUG
				if DEBUG
					votes.each do |name, vote|
						Syslog.debug("%s voted: \"%s\"", name, vote)
					end
				end

				# Check if we have our minimum threshold of votes. Default to HODL if 
				if votes.size < 1 #10
					Syslog.info("Only received %d votes (< 10), HODL!", votes.size)
					#client.update("Hourly voting closed.  Not enough votes to make a decision.  HODL!!! (Need minimum 10 votes... Maybe you should retweet my poll tweet?)") 
					$decision = "HODL"
				else
					# We have enough votes!  Make some trades...
					Syslog.info("Enough votes tallied, making a decision!")
					# TODO: Determine which keyword won the vote and set the decision variable
					tally = {}
					tally[:buy]  = 0
					tally[:sell] = 0
					tally[:hodl] = 0
					votes.each do |name, vote|
						tally[:buy]  += 1 if vote == "BUY"
						tally[:sell] += 1 if vote == "SELL"
						tally[:hodl] += 1 if vote == "HODL"
					end
					# Find the largest number in the tally hash and return the associated key(s)
					winner = tally.reduce({}){|h,(k,v)| (h[v] ||= []) << k;h}.max
					# There can be only one:
					$decision = "HODL" #default
					if winner[1].count > 1
						# Tie!  HODL...
						message = "Result of the poll was a tie! I'm gonna %s. (%d BUY | %d SELL | %d HODL)" % [$decision, tally[:buy], tally[:sell], tally[:hodl]]
						Syslog.info(message)
						client.update(message) if ! DEBUG
					else
						# Winner!
						$decision = "BUY"  if winner[1][0] == :buy
						$decision = "SELL" if winner[1][0] == :sell
						$decision = "HODL" if winner[1][0] == :hodl

						# Post poll results
						message = "The results for Poll %d are in! %s is the winner! (%d BUY | %d SELL | %d HODL)" % [$pollid, $decision, tally[:buy], tally[:sell], tally[:hodl]]
						Syslog.info(message)
						client.update(message) if ! DEBUG
					end

				end
			end

			# Execute desired trade via Cryptomnio
			Syslog.info("Executing trades via Cryptomnio...")
			case $decision
			when "BUY"
				# Determine 10% of USD
				balance = @wallet_balances["usd"]["amount"].to_f
				$amount  = balance * 0.1
				# TODO: Determine BTC value of USD
				$volume = 0
				# Place BID order
				message = "BUYing %0.8f BTC (10 percent of \$%s USD) at MARKET" % [ $volume, balance ]
				Syslog.info(message)
@order_id = 3 if DEBUG
				$order_id = cryptomnio.order_create( @ckey, "buy", "MARKET", "btc_usd", $volume ) if ! DEBUG
			when "SELL"
				# Determine 10% of BTC
				balance = @wallet_balances["btc"]["amount"].to_f
				$volume = balance * 0.1
				# Place ASK order
				message = "SELLing %0.8f BTC (10 percent of %s BTC) at MARKET" % [ $volume, balance ] 
				Syslog.info(message)
@order_id = 3 if DEBUG
				$order_id = cryptomnio.order_create( @ckey, "sell", "MARKET", "btc_usd", $volume ) if ! DEBUG
			else
				# HODL
				$order_id = nil
			end

			if $order_id
				# Wait until order clears
# TODO: Cryptomnio bug, order status isn't updating
#				loop do
#					sleep 1
#					order_info = cryptomnio.order_get( @ckey, @order_id )
#
#					break if order_info["status"] != "open"
#				end

				# Fudge an order check; assume it clears in under 10 seconds
				sleep 10

				# Refresh Wallet Balances
				@wallet_balances = cryptomnio.wallet_get( @ckey )
				$balance_btc = @wallet_balances["btc"]["amount"].to_f
				$balance_usd = @wallet_balances["usd"]["amount"].to_f

				# Post trade results
				Syslog.info("Posting trade results...")
				case $decision
				when "BUY"
					tweet = "Trade Complete: BUY 10\% of USD: %0.8d BTC ($%0.2d USD)\nTrading fee: %0.02\nAccount Balances:\n\tBTC: %0.8d\n\tUSD: $%0.2d" % [ @order_info["volume"], usd_value, @order_info["fee"], $balance_btc, $balance_usd ]
				when "SELL"
					tweet = "Trade Complete: SELL 10\% of BTC: %0.8d BTC ($%0.2d USD, 10% of BTC)\nTrading fee: %0.02\nAccount Balances:\n\tBTC: %0.8d\n\tUSD: $%0.2d" % [ @order_info["volume"], usd_value, @order_info["fee"], $balance_btc, $balance_usd ]
				end
				if tweet.length > 280
					Syslog.err("Error: Poll tweet too long! (%d characters", tweet.length)
				end
				puts tweet if DEBUG
#				client.update(tweet)
			end


			sleep 60 if ! DEBUG
		else
			if lastminute != $minute
				$dots = ""
			else
				$dots = $dots + "."
			end
			printf("\rWaiting until minute 55... (Current minute: %02d) %s", $minute, $dots)
			STDOUT.flush
			sleep 0.05
		end
	end

end
